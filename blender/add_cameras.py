import bpy
from mathutils import Matrix
import numpy as np
import builtins as __builtin__

txt_path = "" # PUT your txt folder path generated by COLMAP
intrinsic_path = f"{txt_path}/cameras.txt"
extrinsic_path = f"{txt_path}/images.txt"


def print(*datas):
    """
    Function for use print option in blender script
    """
    window=bpy.context.window_manager.windows[0]
    screen = window.screen
    for area in screen.areas:
        if area.type == 'CONSOLE':
            for data in datas:
                bpy.ops.console.scrollback_append(
                    {'window': window, 'screen': screen, 'area': area},
                    text=str(data))


def quaternion2rotation_matrix(qw, qx, qy, qz):
    R = np.zeros((3, 3), dtype=np.float32)

    R[0, 0] = 1 - 2 * qy ** 2 - 2 * qz ** 2
    R[0, 1] = 2 * qx * qy - 2 * qz * qw
    R[0, 2] = 2 * qx * qz + 2 * qy * qw
    R[1, 0] = 2 * qx * qy + 2 * qz * qw
    R[1, 1] = 1 - 2 * qx ** 2 - 2 * qz ** 2
    R[1, 2] = 2 * qy * qz - 2 * qx * qw
    R[2, 0] = 2 * qx * qz - 2 * qy * qw
    R[2, 1] = 2 * qy * qz + 2 * qx * qw
    R[2, 2] = 1 - 2 * qx ** 2 - 2 * qy ** 2

    return R

def flength_offset2intrinsic_matrix(fx, fy, px, py):
    K = np.array([[fx, 0, px], [0, fy, py], [0, 0, 1]], dtype=np.float32)
    
    return K

def translation2translation_matrix(tx, ty, tz):
    t = np.array([[tx], [ty], [tz]], dtype=np.float32)

    return t

def add_camera(K, R, t, scale, name):
    K, R_world2cv, T_world2cv = K, R, t
    scene = bpy.context.scene

    sensor_width_in_mm = K[1,1]*K[0,2] / (K[0,0]*K[1,2])
    sensor_height_in_mm = 1 
    resolution_x_in_px = K[0,2]*2 
    resolution_y_in_px = K[1,2]*2 

    s_u = resolution_x_in_px / sensor_width_in_mm
    s_v = resolution_y_in_px / sensor_height_in_mm
    f_in_mm = K[0,0] / s_u
    
    scene.render.resolution_x = int(resolution_x_in_px / scale)
    scene.render.resolution_y = int(resolution_y_in_px / scale)
    scene.render.resolution_percentage = scale * 100

    R_bcam2cv = Matrix(
        ((1, 0,  0),
         (0, -1, 0),
         (0, 0, -1)))

    R_cv2world = R_world2cv.T
    rotation =  R_cv2world @ R_bcam2cv
    location = - R_cv2world @ T_world2cv
    
    
    bpy.ops.object.add(type='CAMERA', location=location)
    ob = bpy.context.object
    ob.name = f'{name}Obj'
    cam = ob.data
    cam.name = name

    cam.type = 'PERSP'
    cam.lens = f_in_mm 
    cam.lens_unit = 'MILLIMETERS'
    cam.sensor_width  = sensor_width_in_mm
    ob.rotation_mode = 'XYZ'
    ob.rotation_euler = Matrix(rotation.tolist()).to_euler('XYZ')
    
    cam.show_name = True
    scene.camera = ob


with open(intrinsic_path, "r") as i, open(extrinsic_path, "r") as e:
    iline = i.readline()
    while iline.startswith("#"):
        iline = i.readline()
    _, __, width, height, fx, fy, px, py, *_ = iline.split(' ')
    K = flength_offset2intrinsic_matrix(fx=fx, fy=fy, px=px, py=py)

    extrinsics = []
    eline = e.readline()
    while eline != "":
        if eline.endswith('.png\n'):
            _, qw, qx, qy, qz, tx, ty, tz, __, name = eline.split(' ')
            R = quaternion2rotation_matrix(qw=float(qw), qx=float(qx), qy=float(qy), qz=float(qz))
            t = translation2translation_matrix(tx=tx, ty=ty, tz=tz)
            extrinsics.append([R, t, name.split(".")[0]])
        eline = e.readline()
    
    for extrinsic in extrinsics:
        R, t, name = extrinsic
        add_camera(K=K, R=R, t=t, scale=1, name=name)